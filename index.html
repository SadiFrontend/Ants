<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Ants Form Text</title>
    <style>
        html, body {
            margin: 0;
            padding: 0;
            height: 100%;
            background: black;
            overflow: hidden;
        }
        canvas {
            display: block;
            width: 100%;
            height: 100%;
        }
        #textInput {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 48px;
            padding: 15px 30px;
            background: rgba(0, 0, 0, 0.9);
            color: white;
            border: 3px solid white;
            font-family: Arial, sans-serif;
            text-align: center;
            outline: none;
            z-index: 100;
            border-radius: 10px;
        }
        #textInput::placeholder {
            color: rgba(255, 255, 255, 0.5);
        }
    </style>
</head>
<body>
    <input type="text" id="textInput" placeholder="Type text..." maxlength="15">
    <script>
        var Input = {
            mouse: { x: 0, y: 0, down: false }
        };
        
        document.addEventListener("mousemove", function(event) {
            Input.mouse.x = event.clientX;
            Input.mouse.y = event.clientY;
        });
        
        document.addEventListener("mousedown", function(event) {
            Input.mouse.down = true;
        });
        
        document.addEventListener("mouseup", function(event) {
            Input.mouse.down = false;
        });
        
        document.addEventListener("keydown", function(event) {
            if (event.keyCode === 32) { // Space
                event.preventDefault();
                for (var i = 0; i < 50; i++) {
                    createAnt();
                }
            }
        });

        var canvas = document.createElement("canvas");
        document.body.appendChild(canvas);
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
        var ctx = canvas.getContext("2d");
        
        var textInput = document.getElementById('textInput');
        var textPoints = [];
        var formingText = false;
        var currentText = '';
        
        // Spatial grid for faster nearest neighbor search
        var gridSize = 50;
        var spatialGrid = {};
        
        function getGridKey(x, y) {
            var gx = Math.floor(x / gridSize);
            var gy = Math.floor(y / gridSize);
            return gx + ',' + gy;
        }
        
        function addToGrid(ant) {
            var key = getGridKey(ant.x, ant.y);
            if (!spatialGrid[key]) spatialGrid[key] = [];
            spatialGrid[key].push(ant);
            ant.gridKey = key;
        }
        
        function removeFromGrid(ant) {
            if (ant.gridKey && spatialGrid[ant.gridKey]) {
                var index = spatialGrid[ant.gridKey].indexOf(ant);
                if (index > -1) {
                    spatialGrid[ant.gridKey].splice(index, 1);
                }
            }
        }
        
        function updateGrid(ant) {
            var newKey = getGridKey(ant.x, ant.y);
            if (newKey !== ant.gridKey) {
                removeFromGrid(ant);
                addToGrid(ant);
            }
        }
        
        function getNearbyAnts(x, y, range) {
            var nearby = [];
            var gx = Math.floor(x / gridSize);
            var gy = Math.floor(y / gridSize);
            var cellRange = Math.ceil(range / gridSize);
            
            for (var dx = -cellRange; dx <= cellRange; dx++) {
                for (var dy = -cellRange; dy <= cellRange; dy++) {
                    var key = (gx + dx) + ',' + (gy + dy);
                    if (spatialGrid[key]) {
                        nearby = nearby.concat(spatialGrid[key]);
                    }
                }
            }
            return nearby;
        }
        
        textInput.addEventListener('input', function() {
            var newText = textInput.value.trim().toUpperCase();
            if (newText.length > 0 && newText !== currentText) {
                currentText = newText;
                generateTextPoints(newText);
                formingText = true;
            } else if (newText.length === 0) {
                textPoints = [];
                formingText = false;
                currentText = '';
                // Release all ants
                for (var i = 0; i < ants.length; i++) {
                    if (ants[i].assignedPoint) {
                        ants[i].assignedPoint = null;
                    }
                }
            }
        });
        
        function generateTextPoints(text) {
            console.log('Generating points for: "' + text + '"');
            textPoints = [];
            
            // Release all current assignments
            for (var i = 0; i < ants.length; i++) {
                if (ants[i].assignedPoint) {
                    ants[i].assignedPoint = null;
                }
            }
            
            // Create temporary canvas
            var tempCanvas = document.createElement('canvas');
            tempCanvas.width = canvas.width;
            tempCanvas.height = canvas.height;
            var tempCtx = tempCanvas.getContext('2d');
            
            // Calculate font size based on text length
            var baseFontSize = 200;
            var fontSize = Math.min(baseFontSize, canvas.width / (text.length * 0.6));
            
            // Draw text
            tempCtx.font = 'bold ' + fontSize + 'px Arial, sans-serif';
            tempCtx.fillStyle = 'white';
            tempCtx.textAlign = 'center';
            tempCtx.textBaseline = 'middle';
            tempCtx.fillText(text, canvas.width / 2, canvas.height / 2);
            
            // Get image data
            var imageData = tempCtx.getImageData(0, 0, canvas.width, canvas.height);
            var pixels = imageData.data;
            
            // Find bounds of text
            var minX = canvas.width, maxX = 0, minY = canvas.height, maxY = 0;
            for (var y = 0; y < canvas.height; y++) {
                for (var x = 0; x < canvas.width; x++) {
                    var index = (y * canvas.width + x) * 4;
                    if (pixels[index + 3] > 128) {
                        if (x < minX) minX = x;
                        if (x > maxX) maxX = x;
                        if (y < minY) minY = y;
                        if (y > maxY) maxY = y;
                    }
                }
            }
            
            // Sample points with adaptive density
            var spacing = 3; // Denser sampling for better text
            var pointCount = 0;
            
            for (var y = minY; y <= maxY; y += spacing) {
                for (var x = minX; x <= maxX; x += spacing) {
                    if (x < 0 || x >= canvas.width || y < 0 || y >= canvas.height) continue;
                    var index = (y * canvas.width + x) * 4;
                    if (pixels[index + 3] > 128) {
                        textPoints.push({
                            x: x,
                            y: y,
                            assigned: false,
                            ant: null
                        });
                        pointCount++;
                    }
                }
            }
            
            console.log('Generated ' + pointCount + ' target points');
            console.log('Available ants: ' + ants.length);
            
            // If we don't have enough ants, create more
            if (ants.length < pointCount * 0.8) {
                var needed = Math.ceil(pointCount * 0.9) - ants.length;
                console.log('Creating ' + needed + ' more ants');
                for (var i = 0; i < needed; i++) {
                    createAnt();
                }
            }
        }

        class Ant {
            constructor(x, y) {
                this.x = x;
                this.y = y;
                this.angle = Math.random() * Math.PI * 2;
                this.speed = 2 + Math.random() * 1;
                this.size = 2;
                this.state = 'wander';
                this.stateTimer = 0;
                this.targetX = x;
                this.targetY = y;
                this.turnSpeed = 0.08 + Math.random() * 0.04;
                this.assignedPoint = null;
                this.reachedTarget = false;
                this.gridKey = null;
                addToGrid(this);
            }
            
            findClosestPoint() {
                if (textPoints.length === 0) return null;
                
                var closestPoint = null;
                var closestDist = Infinity;
                
                // Use smarter assignment - prioritize unassigned points
                for (var i = 0; i < textPoints.length; i++) {
                    var point = textPoints[i];
                    if (point.assigned) continue;
                    
                    var dx = point.x - this.x;
                    var dy = point.y - this.y;
                    var dist = dx * dx + dy * dy; // Use squared distance for speed
                    
                    if (dist < closestDist) {
                        closestDist = dist;
                        closestPoint = point;
                    }
                }
                
                return closestPoint;
            }
            
            update() {
                this.stateTimer--;
                
                if (formingText && textPoints.length > 0) {
                    // Assign to closest point if not assigned
                    if (!this.assignedPoint || this.assignedPoint.assigned === false) {
                        var point = this.findClosestPoint();
                        if (point) {
                            // Release old assignment
                            if (this.assignedPoint) {
                                this.assignedPoint.assigned = false;
                                this.assignedPoint.ant = null;
                            }
                            // New assignment
                            this.assignedPoint = point;
                            point.assigned = true;
                            point.ant = this;
                            this.reachedTarget = false;
                            this.state = 'forming';
                        }
                    }
                    
                    if (this.assignedPoint) {
                        this.targetX = this.assignedPoint.x;
                        this.targetY = this.assignedPoint.y;
                        this.state = 'forming';
                        
                        var dx = this.targetX - this.x;
                        var dy = this.targetY - this.y;
                        var dist = Math.sqrt(dx * dx + dy * dy);
                        
                        if (dist < 2) {
                            this.reachedTarget = true;
                            this.x = this.targetX;
                            this.y = this.targetY;
                        }
                    }
                } else {
                    // Release assignment when not forming text
                    if (this.assignedPoint) {
                        this.assignedPoint.assigned = false;
                        this.assignedPoint.ant = null;
                        this.assignedPoint = null;
                        this.reachedTarget = false;
                    }
                    
                    // Wander behavior
                    if (this.stateTimer <= 0) {
                        this.state = 'wander';
                        this.stateTimer = 60 + Math.random() * 120;
                        this.targetX = Math.random() * canvas.width;
                        this.targetY = Math.random() * canvas.height;
                    }
                }
                
                // Mouse attraction when not forming text
                if (Input.mouse.down && !formingText) {
                    this.targetX = Input.mouse.x;
                    this.targetY = Input.mouse.y;
                    this.state = 'follow';
                }
                
                // Movement logic
                if (!this.reachedTarget) {
                    var dx = this.targetX - this.x;
                    var dy = this.targetY - this.y;
                    var dist = Math.sqrt(dx * dx + dy * dy);
                    
                    if (dist > 1) {
                        var targetAngle = Math.atan2(dy, dx);
                        
                        // Normalize angle difference
                        var angleDiff = targetAngle - this.angle;
                        while (angleDiff > Math.PI) angleDiff -= Math.PI * 2;
                        while (angleDiff < -Math.PI) angleDiff += Math.PI * 2;
                        
                        // Smooth turning
                        this.angle += Math.sign(angleDiff) * Math.min(Math.abs(angleDiff), this.turnSpeed);
                        
                        // Move forward
                        var moveSpeed = this.state === 'forming' ? this.speed * 1.5 : this.speed;
                        this.x += Math.cos(this.angle) * moveSpeed;
                        this.y += Math.sin(this.angle) * moveSpeed;
                    }
                }
                
                // Collision avoidance with nearby ants
                if (!this.reachedTarget) {
                    var nearby = getNearbyAnts(this.x, this.y, 15);
                    for (var i = 0; i < nearby.length; i++) {
                        var other = nearby[i];
                        if (other === this) continue;
                        if (other.reachedTarget) continue;
                        
                        var dx = this.x - other.x;
                        var dy = this.y - other.y;
                        var dist = Math.sqrt(dx * dx + dy * dy);
                        
                        if (dist < 10 && dist > 0) {
                            var avoidForce = (10 - dist) / 10;
                            this.x += (dx / dist) * avoidForce * 2;
                            this.y += (dy / dist) * avoidForce * 2;
                        }
                    }
                }
                
                // Keep on screen with wrapping
                if (this.x < 0) this.x = canvas.width;
                if (this.x > canvas.width) this.x = 0;
                if (this.y < 0) this.y = canvas.height;
                if (this.y > canvas.height) this.y = 0;
                
                // Update spatial grid
                updateGrid(this);
            }
            
            draw() {
                ctx.fillStyle = 'white';
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
                ctx.fill();
            }
        }

        var ants = [];
        
        function createAnt() {
            ants.push(new Ant(
                Math.random() * canvas.width,
                Math.random() * canvas.height
            ));
        }
        
        // Create initial ants
        for (var i = 0; i < 500; i++) {
            createAnt();
        }
        
        function animate() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            for (var i = 0; i < ants.length; i++) {
                ants[i].update();
                ants[i].draw();
            }
            
            requestAnimationFrame(animate);
        }
        
        animate();
        
        console.log('Started with ' + ants.length + ' ants');
    </script>
</body>
</html>